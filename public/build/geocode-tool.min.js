(function (global){
var ym = { modules: global.ymaps.modules };

(function (modules){
var project = { DEBUG: false };
if (typeof modules == 'undefined' && typeof require == 'function') {
    var modules = require('ym');
}

modules.define('util.providePackage', ['system.mergeImports'], function (provide, mergeImports) {
    provide(function (srcPackage, packageArgs) {
        var packageProvide = packageArgs[0],
            packageModules = Array.prototype.slice.call(packageArgs, 1),
            ns = mergeImports.joinImports(srcPackage.name, {}, srcPackage.deps, packageModules);

        packageProvide(ns);
    });
});
})(ym.modules);

ym.modules.define('app-config', [
], function (provide) {
  provide({
    map: {
      container: 'ymap',
      state: {
        center: [55.751574, 37.573856],
        zoom: 9,
        controls: ['zoomControl', 'geolocationControl', 'typeSelector']
      },
      options: {
        suppressMapOpenBlock: true
      }
    },
    model: {
      stub: {
        dataType: 'CSV',
        data: 'Москва~Санкт-Петербург~Новосибирск~Екатеринбург~Нижний Новгород~Казань~Челябинск~Омск~Самара~Ростов-на-Дону~Уфа~Красноярск~Пермь~Воронеж~Волгоград',
        delim: '~'
      },
      source: {
        url: 'http://localhost:8888',
        method: 'POST'
      }
    }
  });
});

ym.modules.define('app-dom-view', [
  'util.defineClass',
  'event.Manager'
], function (provide, defineClass, EventManager) {

  var DomView = defineClass(function (config) {
    this.events = new EventManager();
    this._form = jQuery('form');
    this._setupListeners();
  }, {
    getData: function () {
      return this._form.serialize();
    },
    setInboxPlaceholder: function (placeholder) {
      this._form.find('#inbox').attr('placeholder', placeholder);

      return this;
    },
    setDelimPlaceholder: function (placeholder) {
      this._form.find('#delim').attr('placeholder', placeholder);

      return this;
    },
    _setupListeners: function () {
      this._form
        .on('change', 'select#data-type', jQuery.proxy(this._onDataTypeChange, this))
        .on('submit', jQuery.proxy(this._onFormSubmit, this));
    },
    _clearListeners: function () {
    },
    _onDataTypeChange: function (e) {
      e.preventDefault();
    },
    _onFormSubmit: function (e) {
      e.preventDefault();

      this.events.fire({
        type: 'formsubmit',
        target: this
      });
    },
    _onFormReset: function (e) {
      e.preventDefault();
    }
  });

  provide(DomView);
});

ym.modules.define('app-map-view', [
  'util.defineClass',
  'Map',
  'ObjectManager',
  'templateLayoutFactory',
  'event.Manager'
], function (provide, defineClass, Map, ObjectManager, templateLayoutFactory, EventManager) {

  var MapView = defineClass(function (config) {
    this.events = new EventManager();
    this._map = new Map(config.container, config.state, config.options);
    this._objects = this._createObjectManager();
    this._map.geoObjects.add(this._objects);
  }, {
    render: function (data) {
      this._objects.add(data);
      this.focusOnObjects();

      return this;
    },
    clear: function () {
      this._objects.removeAll();

      return this;
    },
    _createObjectManager: function () {
      return new ObjectManager({
        geoObjectBalloonContentLayout: templateLayoutFactory.createClass([
          '<h3>{{ properties.name }}</h3>',
          '<p>{{ properties.description }}</p>'
        ].join(''))
      });
    },
    focusOnObjects: function () {
      this._map.setBounds(this._objects.getBounds(), {
        checkZoomRange: true,
        zoomMargin: 20
      });

    return this;
    },
    _setupListeners: function () {
    },
    _clearListeners: function () {
    },
  });

  provide(MapView);
});

ym.modules.define('app', [
  'util.defineClass',
  'app-map-view',
  'app-dom-view',
  'geocode-model-factory',
  'app-config'
], function (provide, defineClass, MapView, DomView, modelFactory, config) {
  var App = defineClass(function () {
    this._mapView = new MapView(config.map);
    this._domView = new DomView(config.ui);
  }, {
    init: function () {
      var stub = config.model.stub;

      var model = this._createModel(stub.dataType, stub.data, {
        delim: stub.delim,
        provider: config.model.source
      });

      this._domView
        .setInboxPlaceholder(stub.data)
        .setDelimPlaceholder(stub.delim);

      model.geocode().then(this._onDataLoad, this);
    },
    _createModel: function (dataType, data, options) {
      return this._geocodeModel = modelFactory.create(dataType, data, options);
    },
    _removeModel: function () {
      this._geocodeModel.clear();
      this._geocodeModel = null;
    },
    _onDataLoad: function (data) {
      this._mapView
        .clear()
        .render(data.result);
    }
  });

  provide(App);
});

ym.modules.define('base-geocode-model', [
  'util.defineClass',
  'util.extend',
  'proxy-geocode-provider',
  'geocode'
], function (provide, defineClass, extend, ProxyGeocodeProvider, geocode) {
  var BaseGeocodeModel = defineClass(function (data, options) {
    this._data = data || '';
    this._options = options;
    this._response = null;
    this._error = null;
    this._provider = new ProxyGeocodeProvider(options.provider);
  }, {
    geocode: function (options) {
      var promise;

      this.each(function (it) {
        promise = geocode(it.request, extend({}, options, it.options, {
          provider: this._provider
        }));
      });

      return promise.then(this._onLoad, this._onError, this);
    },
    /**
     * Should be overrided
     */
    each: function (fn) {},
    clear: function () {
      this._data = null;
      this._response = null;
      this._error = null;
    },
    getData: function () {
      return this._data;
    },
    getResponse: function () {
      return this._response;
    },
    getError: function () {
      return this._error;
    },
    _onLoad: function (response) {
      return this._response = response.data;
    },
    _onError: function (err) {
      throw this._error = err;
    }
  });

  provide(BaseGeocodeModel);
});

ym.modules.define('csv-geocode-model', [
  'util.defineClass',
  'base-geocode-model'
], function (provide, defineClass, BaseModel) {
  var CSVGeocodeModel = defineClass(function (data, options) {
    CSVGeocodeModel.superclass.constructor.call(this, data, options);
  }, BaseModel, {
    each: function (fn) {
      this._data.trim().split(this._options.delim).forEach(function (it, index) {
        fn.call(this, { request: it }, index);
      }, this);
    }
  });

  provide(CSVGeocodeModel);
});

ym.modules.define('geojson-geocode-model', [
  'util.defineClass',
  'base-geocode-model'
], function (provide, defineClass, BaseModel) {
  var GeoJSONGeocodeModel = defineClass(function (data, options) {
    GeoJSONGeocodeModel.superclass.constructor.call(this, data, options);
  }, BaseModel, {
    each: function (fn) {
      var data = this._data.trim();
      if(data[0] === '[') {
        data = JSON.parse(data);
      }
      else {
        data = JSON.parse('[' + data + ']');
        if(data.length === 1 && Array.isArray(data[0].features)) {
          data = data[0].features;
        }
      }
      data.forEach(function (it, index) {
        fn.call(this, { request: it.geometry.coordinates }, index);
      }, this);
    }
  });

  provide(GeoJSONGeocodeModel);
});

ym.modules.define('geocode-model-factory', [
  'csv-geocode-model',
  'geojson-geocode-model'
], function (provide, CSVGeocodeModel, GeoJSONGeocodeModel) {
  provide({
    create: function (dataType, data, options) {
      switch(dataType) {
        case 'CSV':
          return new CSVGeocodeModel(data, options);
        case 'GeoJSON':
          return new GeoJSONGeocodeModel(data, options);
        default:
          throw new TypeError('Unknown DataType');
      }
    }
  });
});

ym.modules.define('proxy-geocode-provider', [
  'util.defineClass',
  'util.extend',
  'vow',
  'component.xhr'
], function (provide, defineClass, extend, vow, XHR) {

  var config = { timeout: 10 };
  var requests = [];
  var defer = vow.defer();
  var timer;

  function cleanUp() {
    timer = null;
    requests.length = 0;
    defer = vow.defer();
  }

  function sendRequest() {
    var xhr = new XHR(config.url, {
      method: config.method,
      data: requests
    }).then(
      defer.resolve,
      defer.reject,
      defer.notify,
      defer
    );
    cleanUp();
  }

  function normalizeOptions(options) {
    if(options == null || Object.keys(options) == 'provider') {
      return;
    }

    return {
      boundedBy: options.boundedBy,
      strictBounds: options.strictBounds
    };
  }

  var ProxyGeocodeProvider = defineClass(function (options) {
    extend(config, options);
  }, {
    geocode: function (request, options) {
      requests.push({ request: request, options: normalizeOptions(options) });
      clearTimeout(timer);
      timer = setTimeout(sendRequest, config.timeout);

      return defer.promise();
    }
  });

  provide(ProxyGeocodeProvider);
});

ym.modules.define('component.querystring', [
], function (provide) {
  provide({
    parse: function (s) {
      var params = {};

      try {
        if(s.indexOf('?') > -1) {
          s = s.split('?')[1];
        }

        s.replace(/[^?&]+(?=&|$)/g, function (s) {
          var param = s.split('=');

          params[decodeURI(param[0])] = decodeURIComponent(param[1]);
        });
      }
      catch (e) {}

      return params;
    },
    stringify: function (data) {
      var params = [];

      try {
        for(var param in data) {
          params.push(encodeURI(param) + '=' + encodeURIComponent(data[param]));
        }
      }
      catch (e) {}

      return params.join('&');
    }
  });
});

ym.modules.define('component.xhr', [
  'vow',
  'component.querystring'
], function (provide, vow, querystring) {
  var XMLHttpRequest = window.XDomainRequest || window.XMLHttpRequest;
  var parseHeaders = function (headers) {
    return headers.split('\u000d\u000a').reduce(function (result, line) {
      var parts = line.split('\u003a\u0020');
      if(parts.length == 2) {
        result[parts[0].toLowerCase()] = parts[1].trim();
      }
      return result;
    }, {});
  };

  function XHR(url, options) {
    options = options || {};
    var defer = vow.defer();
    var xhr = new XMLHttpRequest();
    var data = options.data || null;
    var headers = options.headers || {};
    var method = (options.method || 'GET').toUpperCase();
    var timeout = options.timeout || 30000;

    function cleanUp() {
      xhr.onload = xhr.onerror = null;
    }

    if(!headers['X-Requested-With']) {
      headers['X-Requested-With'] = 'XMLHttpRequest';
    }

    if(data) {
      if(method === 'GET') {
        url += '?' + querystring.stringify(data);
      }
      /**
       * All objects will be sended as JSON string by default.
       * To send ArrayBufferView, Blob, Document and FormData use proper Content-Type header.
       */
      else if(typeof data === 'object' && !headers['Content-Type']) {
        data = JSON.stringify(data);
        headers['Content-Type'] = 'application/json';
      }
    }

    xhr.onload = function () {
      var headers = this.getAllResponseHeaders();
      var cType = this.getResponseHeader('Content-Type') || 'text/plain';
      var response = cType.indexOf('xml') > -1 && this.responseXML || this.response || this.responseText;

      if(cType.indexOf('json') > -1 && typeof response === 'string') {
        try {
          response = JSON.parse(response);
        }
        catch(e) {
          return defer.reject({
            code: 500,
            message: 'JSON Parse Error ' + e.message
          });
        }
      }

      cleanUp();
      defer.resolve({
        code: this.status,
        data: response,
        headers: !!options.parseResponseHeaders?
          parseHeaders(headers) : headers
      });
    };

    xhr.onerror = function () {
      defer.reject(new Error({
        code: this.status || 500,
        message: this.statusText || 'Internal Server Error'
      }));
    };

    xhr.open(method, url, true);

    Object.keys(headers).forEach(function (key) {
      xhr.setRequestHeader(key, headers[key]);
    });

    xhr.send(data);

    return defer.promise()
      .timeout(timeout)
      .fail(function (e) {
        cleanUp();
        if(e instanceof vow.TimedOutError) {
          xhr.abort();
          throw new Error({
            code: 408,
            message: 'Request Timeout'
          });
        }
        throw e;
      });
  }

  provide(XHR);
});

})(this);